# -*- coding: utf-8 -*-
"""Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JO6RZCdIhwIU1rpLRQqNhHRzMUugk_GU
"""

from google.colab import drive
drive.mount('/content/drive')
fname = "/content/drive/My Drive/Colab Notebooks/iris.csv.gz"

import scipy
import sklearn
import pandas as pd
import matplotlib
import numpy as np
from sklearn.model_selection import train_test_split

# Евклид
from scipy.spatial import distance

dataset = pd.read_csv(fname)

print(dataset.head(150))

# Срез: отсекаем классы
x = dataset.values[:, 0:4]

# Оставляем только классы
y = dataset.values[:, 4]

# Перемешать и разделить данные в пропорции 90:10
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.1)

# Euclid
print('[Parameters]: Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  count = 0
  for train_iris, train_iris_class in zip(x_train, y_train):
    sum = 0.0
    for crit_tr, crit_test in zip(train_iris, test_iris):
      sum += (crit_test - crit_tr) ** 2;
    distances.append([sum ** (0.5), count])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.euclidean.html
    # print(distance.euclidean(train_iris, test_iris),' ', sum ** (0.5))
    count += 1
    # print(distances)
  min_dist = min(distances)
  if (y_train[min_dist[1]] != test_iris_class):
    count_loss +=1
  print(f'{test_iris}: {y_train[min_dist[1]]} - {test_iris_class}')
print(f'Loss: {count_loss/15*100}%')

# Hamming
print('[Parameters]: Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  count = 0
  for train_iris, train_iris_class in zip(x_train, y_train):
    sum = 0.0
    for crit_tr, crit_test in zip(train_iris, test_iris):
      sum += abs(crit_test - crit_tr);
    distances.append([sum, count])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cityblock.html
    # print(distance.cityblock(test_iris, train_iris),' ', sum)
    count += 1
    # print(distances)
  min_dist = min(distances)
  if (y_train[min_dist[1]] != test_iris_class):
    count_loss +=1
  print(f'{test_iris}: {y_train[min_dist[1]]} - {test_iris_class}')
print(f'Loss: {count_loss/15*100}%')

# City_Blocks
print('[Parameters]: Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  count = 0
  for train_iris, train_iris_class in zip(x_train, y_train):
    max = -9999
    for crit_tr, crit_test in zip(train_iris, test_iris):
      val = abs(crit_tr - crit_test)
      max = val if val > max else max
    distances.append([max, count])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.chebyshev.html
    # print(distance.chebyshev(train_iris, test_iris),' ', max)
    count += 1
  min_dist = min(distances)
  if (y_train[min_dist[1]] != test_iris_class):
    count_loss +=1
  print(f'{test_iris}: {y_train[min_dist[1]]} - {test_iris_class}')
print(f'Loss: {count_loss/15*100}%')

# Jacquard
print('[Parameters]: Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  count = 0
  for train_iris, train_iris_class in zip(x_train, y_train):
    inter = 0
    for crit_tr, crit_test in zip(train_iris, test_iris):
      if (crit_tr == crit_test):
        inter += 1
    distances.append([(4-inter)/(4), count])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.jaccard.html#scipy.spatial.distance.jaccard
    # print(distance.jaccard(train_iris, test_iris),' ', (4-inter)/(4))
    count += 1
  min_dist = min(distances)
  if (y_train[min_dist[1]] != test_iris_class):
    count_loss +=1
  print(f'{test_iris}: {y_train[min_dist[1]]} - {test_iris_class}')
print(f'Loss: {count_loss/15*100}%')

# Cosine
print('[Parameters]: Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  count = 0
  for train_iris, train_iris_class in zip(x_train, y_train):
    dot_product = np.dot(test_iris, train_iris)
    cosine = 1 - dot_product/(np.linalg.norm(train_iris * np.linalg.norm(test_iris)))
    distances.append([cosine, count])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cosine.html
    # print(distance.cosine(list(test_iris), list(train_iris)),' ', cosine)
    count += 1
  min_dist = min(distances)
  if (y_train[min_dist[1]] != test_iris_class):
    count_loss +=1
  print(f'{test_iris}: {y_train[min_dist[1]]} - {test_iris_class}')
print(f'Loss: {count_loss/15*100}%')