# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dsukCNjJZPcNjQlW0DsUPRoA2DXhDFvC
"""

from google.colab import drive
drive.mount('/content/drive')
fname = "/content/drive/My Drive/Colab Notebooks/iris.csv.gz"

import scipy
import sklearn
import pandas as pd
import matplotlib
import numpy as np
import sys
from sklearn.model_selection import train_test_split

# Евклид
from scipy.spatial import distance

dataset = pd.read_csv(fname)å

print(set(dataset['species']))

# Срез: отсекаем классы
x = dataset.values[:, 0:4]

# Оставляем только классы
y = dataset.values[:, 4]

# Перемешать и разделить данные в пропорции 90:10
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.1)

# KNN
k = int(input('Enter k - number of neighbors: '))
if (k < 1):
  print('k must be natural!')
  sys.exit()
print('Found class - Actual class')
count_loss = 0
for test_iris, test_iris_class in zip(x_test, y_test):
  found_class = ""
  distances = []
  class_count = dict.fromkeys(set(dataset['species']), 0)
  for train_iris, train_iris_class in zip(x_train, y_train):
    sum = 0.0
    for crit_tr, crit_test in zip(train_iris, test_iris):
      sum += (crit_test - crit_tr) ** 2;
    distances.append([sum ** (0.5), train_iris_class])
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.euclidean.html
    # print(distance.euclidean(train_iris, test_iris),' ', sum ** (0.5))
    # print(distances)
  distances.sort()
  neighbors = distances[0:k]
  for touple_ in neighbors:
    class_count[touple_[1]] +=1
  class_ = max(class_count, key=class_count.get)
  if (class_ != test_iris_class):
    count_loss += 1
  print(class_, ' ', test_iris_class)
print(f'Loss: {count_loss/15*100}%')